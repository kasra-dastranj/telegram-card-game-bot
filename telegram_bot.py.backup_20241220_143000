#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ğŸ¤– Telegram Card Game Bot with PvP Support - ÙØ§Ø² Û± (Enhanced & Fixed)
Ø±Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù… Ú©Ø§Ù…Ù„ Ø¨Ø§Ø²ÛŒ Ú©Ø§Ø±Øª Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª PvP Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡ + Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ø¶ÙˆÛŒØª Ú©Ø§Ù†Ø§Ù„
"""

import json
import os
import logging
import random
from datetime import datetime, timedelta
from typing import Optional, List, Dict, Any

import telegram
import telegram.error
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, Bot, BotCommand, BotCommandScope, BotCommandScopeDefault, BotCommandScopeAllGroupChats
from telegram.ext import (
    Application, 
    CommandHandler, 
    CallbackQueryHandler, 
    MessageHandler, 
    filters, 
    ContextTypes
)

# ÙˆØ§Ø±Ø¯ Ú©Ø±Ø¯Ù† Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡
from game_core import DatabaseManager, GameLogic, CardManager, StatType, Card, CardRarity, Player, PvPFight, FightStatus

# ØªÙ†Ø¸ÛŒÙ… Ù„Ø§Ú¯ÛŒÙ†Ú¯  
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler('bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ==================== CONFIG ====================

# Required channel for bot usage
REQUIRED_CHANNEL = '@KhasteNews'

# Panel expiration timeout (15 minutes)
PANEL_TIMEOUT = 15 * 60

# Command scope definitions
PRIVATE_CHAT_COMMANDS = [
    BotCommand("start", "Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ Ùˆ Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ"),
    BotCommand("profile", "Ù†Ù…Ø§ÛŒØ´ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ùˆ Ø¢Ù…Ø§Ø± Ø´Ø®ØµÛŒ"),
    BotCommand("cards", "Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø¬Ù…Ø¹â€ŒØ¢ÙˆØ±ÛŒ Ø´Ø¯Ù‡"),
    BotCommand("claim", "Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Øª Ø±ÙˆØ²Ø§Ù†Ù‡ Ø±Ø§ÛŒÚ¯Ø§Ù†"),
    BotCommand("leaderboard", "Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù„ÛŒØ³Øª Ø¨Ø±ØªØ±ÛŒÙ† Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†"),
    BotCommand("help", "Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø¨Ø§Ø²ÛŒ Ùˆ Ø¯Ø³ØªÙˆØ±Ø§Øª")
]

GROUP_CHAT_COMMANDS = [
    BotCommand("fight", "Ø´Ø±ÙˆØ¹ Ú†Ø§Ù„Ø´ PvP Ø¯Ø± Ú¯Ø±ÙˆÙ‡"),
    BotCommand("claim", "Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Øª Ø±ÙˆØ²Ø§Ù†Ù‡ Ø±Ø§ÛŒÚ¯Ø§Ù†"),
    BotCommand("leaderboard", "Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù„ÛŒØ³Øª Ø¨Ø±ØªØ±ÛŒÙ† Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†"),
    BotCommand("help", "Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø¨Ø§Ø²ÛŒ")
]

DEFAULT_CONFIG = {
    "bot_settings": {
        "token": "8494533147:AAGKuMEg0gyIEiInzBqU9pSwIUyE_Lum6h4",
        "admin_user_ids": [5735941901, 1431545583],
        "webhook_url": None,
        "webhook_port": 8443
    },
    "game_settings": {
        "daily_hearts": 5,
        "heart_reset_hours": 24,
        "claim_cooldown_hours": 24,
        "ability_cooldown_hours": 24,
        "max_cards_per_page": 8
    },
    "image_settings": {
        "card_images_path": "/root/card game/card_images/",
        "default_card_image": "/root/card game/card_images/default.png",
        "enable_images": True
    },
    "texts": {
        "help": None  # Ù‚Ø§Ø¨Ù„ Ù¾ÛŒÚ©Ø±Ø¨Ù†Ø¯ÛŒØ› Ø§Ú¯Ø± None Ø¨Ø§Ø´Ø¯ Ø§Ø² Ù…ØªÙ† Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
    }
}

# ==================== UTILITY FUNCTIONS ====================

def ensure_text_content(text: str, fallback: str = "ğŸ“± Ù¾ÛŒØ§Ù… Ø¨Ø¯ÙˆÙ† Ù…Ø­ØªÙˆØ§") -> str:
    """Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² ÙˆØ¬ÙˆØ¯ Ù…Ø­ØªÙˆØ§ÛŒ Ù…ØªÙ†ÛŒ Ø¨Ø±Ø§ÛŒ ØªÙ„Ú¯Ø±Ø§Ù…"""
    if not text or text.strip() == "":
        return fallback
    return text.strip()

def get_card_image_path(card_name: str, config: Dict) -> Optional[str]:
    """Ø¯Ø±ÛŒØ§ÙØª Ù…Ø³ÛŒØ± ØªØµÙˆÛŒØ± Ú©Ø§Ø±Øª Ø¨Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ù‚ÛŒÙ‚â€ŒØªØ±"""
    if not config.get('image_settings', {}).get('enable_images', False):
        logger.debug(f"Images disabled in config for card: {card_name}")
        return None
    
    images_path = config.get('image_settings', {}).get('card_images_path', '/root/card game/card_images/')
    default_image = config.get('image_settings', {}).get('default_card_image', '/root/card game/card_images/default.png')
    
    # Ø§Ø·Ù…ÛŒÙ†Ø§Ù† Ø§Ø² ÙˆØ¬ÙˆØ¯ Ù¾ÙˆØ´Ù‡
    os.makedirs(images_path, exist_ok=True)
    os.makedirs(os.path.dirname(default_image), exist_ok=True)
    
    # Ø¬Ø³ØªØ¬Ùˆ Ø¨Ø±Ø§ÛŒ ØªØµÙˆÛŒØ± Ú©Ø§Ø±Øª Ø¨Ø§ Ú†Ù†Ø¯ÛŒÙ† ÙØ±Ù…Øª
    card_filename = card_name.lower().replace(' ', '_').replace('-', '_')
    possible_extensions = ['.png', '.jpg', '.jpeg', '.webp']
    
    for ext in possible_extensions:
        card_image = os.path.join(images_path, f"{card_filename}{ext}")
        if os.path.exists(card_image):
            logger.debug(f"Found card image: {card_image}")
            return card_image
    
    # Ø§Ú¯Ø± ØªØµÙˆÛŒØ± Ú©Ø§Ø±Øª Ù¾ÛŒØ¯Ø§ Ù†Ø´Ø¯ØŒ Ø§Ø² ØªØµÙˆÛŒØ± Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†
    if os.path.exists(default_image):
        logger.debug(f"Using default image: {default_image}")
        return default_image
    
    logger.warning(f"No image found for card: {card_name}, checked: {images_path}")
    return None

def get_victory_dialog(card_name: str) -> str:
    """Gets a random victory dialog for a card. Supports both old and new formats."""
    dialogs_file = "card_dialogs.json"
    
    # Try to read from the json file
    if os.path.exists(dialogs_file):
        try:
            with open(dialogs_file, 'r', encoding='utf-8') as f:
                all_dialogs = json.load(f)
                entry = all_dialogs.get(card_name)
                lines: List[str] = []
                if isinstance(entry, list):
                    # Old format: list of lines
                    lines = entry
                elif isinstance(entry, dict):
                    # New format: { biography: str, victory_lines: list }
                    vl = entry.get('victory_lines', [])
                    if isinstance(vl, list):
                        lines = vl
                    elif isinstance(vl, str) and vl:
                        lines = [vl]
                if lines:
                    return random.choice(lines)
        except Exception:
            pass  # Fallback to generic
    
    # Generic dialogs as a fallback
    generic = [
        "Another victory!",
        "No one can defeat me!",
        "This was just the beginning!",
        "True power is here!"
    ]
    return random.choice(generic)

async def send_card_image_safely(message, card_name: str, config: Dict, caption: str = None) -> bool:
    """Ø§Ø±Ø³Ø§Ù„ Ø§ÛŒÙ…Ù† ØªØµÙˆÛŒØ± Ú©Ø§Ø±Øª"""
    try:
        image_path = get_card_image_path(card_name, config)
        if not image_path:
            logger.warning(f"No image path returned for {card_name}")
            return False
            
        if not os.path.exists(image_path):
            logger.warning(f"Image file not found: {image_path}")
            return False
            
        with open(image_path, 'rb') as photo:
            await message.reply_photo(
                photo=photo,
                caption=caption
            )
            logger.info(f"Successfully sent image for {card_name}")
        return True
    except Exception as e:
        logger.error(f"Failed to send image for {card_name}: {e}")
        return False

# ==================== PANEL EXPIRATION FUNCTIONS ====================

def ensure_not_expired(query, db: DatabaseManager = None, context: ContextTypes.DEFAULT_TYPE = None) -> bool:
    """Check if a callback query is from an expired panel. Auto-expires after 15 minutes in any chat.
    Also cancels ghost fights in DB and notifies group if possible.
    """
    try:
        if not query.message or not query.message.date:
            return True
        message_age = datetime.now().timestamp() - query.message.date.timestamp()
        if message_age > PANEL_TIMEOUT:
            # Ù¾Ø§Ú©Ø³Ø§Ø²ÛŒ ÙØ§ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ù†Ù‚Ø¶ÛŒ Ùˆ Ù„ØºÙˆ Ø¢Ù†â€ŒÙ‡Ø§
            try:
                (db or DatabaseManager()).cleanup_expired_fights(15)
            except Exception as e:
                logger.warning(f"Cleanup on expiration failed: {e}")
            
            # ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªØ®Ø±Ø§Ø¬ fight_id Ø§Ø² callback Ø¨Ø±Ø§ÛŒ Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ
            try:
                data = query.data or ""
                fight_id = None
                for prefix in ["accept_pvp_", "accept_pvp_random_", "pvp_card_", "pvp_stat_"]:
                    if data.startswith(prefix):
                        parts = data.split("_")
                        fight_id = parts[2] if prefix in ["pvp_card_", "pvp_stat_"] else parts[-1]
                        break
                
                # Schedule notification as a background task
                if fight_id and context:
                    try:
                        import asyncio
                        loop = asyncio.get_event_loop()
                        loop.create_task(
                            context.bot.send_message(
                                chat_id=query.message.chat_id, 
                                text="â° Ú†Ø§Ù„Ø´ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯"
                            )
                        )
                        logger.info(f"Scheduled expiration notification for chat {query.message.chat_id}")
                    except Exception as e:
                        logger.warning(f"Failed to schedule expiration notification: {e}")

            except Exception as e:
                logger.error(f"Error during expiration notification logic: {e}")

            return False
        return True
    except Exception as e:
        logger.error(f"Error checking panel expiration: {e}")
        return True

# ==================== MAIN BOT CLASS ====================

class TelegramCardBot:
    def __init__(self, config_path: str = "game_config.json"):
        # Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª
        self.config = self._load_config(config_path)
        
        # Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³ÛŒØ³ØªÙ…â€ŒÙ‡Ø§ÛŒ Ù¾Ø§ÛŒÙ‡
        self.db = DatabaseManager()
        self.game = GameLogic(self.db)
        self.card_manager = CardManager(self.db)
        
        # ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø±Ø¨Ø§Øª
        self.bot_token = self.config['bot_settings']['token']
        self.admin_ids = self.config['bot_settings']['admin_user_ids']
        
        if self.bot_token == "YOUR_BOT_TOKEN_HERE":
            raise ValueError("âš  Ù„Ø·ÙØ§Ù‹ ØªÙˆÚ©Ù† Ø±Ø¨Ø§Øª Ø±Ø§ Ø¯Ø± game_config.json ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒØ¯!")
        
        print(f"âœ… Ø±Ø¨Ø§Øª Ø¢Ù…Ø§Ø¯Ù‡ Ø´Ø¯ Ø¨Ø§ {len(self.admin_ids)} Ø§Ø¯Ù…ÛŒÙ†")
    
    def _load_config(self, config_path: str) -> Dict:
        """Ø¨Ø§Ø±Ú¯ÛŒØ±ÛŒ ÛŒØ§ Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ ØªÙ†Ø¸ÛŒÙ…Ø§Øª"""
        if os.path.exists(config_path):
            with open(config_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        else:
            # Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒÙ„ ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ù¾ÛŒØ´â€ŒÙØ±Ø¶
            with open(config_path, 'w', encoding='utf-8') as f:
                json.dump(DEFAULT_CONFIG, f, indent=4, ensure_ascii=False)
            return DEFAULT_CONFIG

    # ==================== COMMAND SETUP ====================
    
    async def setup_bot_commands(self, application: Application):
        """ØªÙ†Ø¸ÛŒÙ… Ø¯Ø³ØªÙˆØ±Ø§Øª Ø±Ø¨Ø§Øª Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø¯ÙˆØ¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù"""
        try:
            # ØªÙ†Ø¸ÛŒÙ… Ø¯Ø³ØªÙˆØ±Ø§Øª Ø¨Ø±Ø§ÛŒ Ú†Øªâ€ŒÙ‡Ø§ÛŒ Ø®ØµÙˆØµÛŒ
            await application.bot.set_my_commands(
                commands=PRIVATE_CHAT_COMMANDS,
                scope=BotCommandScopeDefault()
            )
            logger.info(f"Set {len(PRIVATE_CHAT_COMMANDS)} commands for private chats")
            
            # ØªÙ†Ø¸ÛŒÙ… Ø¯Ø³ØªÙˆØ±Ø§Øª Ø¨Ø±Ø§ÛŒ Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§
            await application.bot.set_my_commands(
                commands=GROUP_CHAT_COMMANDS,
                scope=BotCommandScopeAllGroupChats()
            )
            logger.info(f"Set {len(GROUP_CHAT_COMMANDS)} commands for group chats")
            
        except Exception as e:
            logger.error(f"Failed to set bot commands: {e}")
    
    def _is_command_allowed_in_chat(self, command: str, chat_type: str) -> bool:
        """Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ø¯Ø³ØªÙˆØ± Ø¯Ø± Ù†ÙˆØ¹ Ú†Øª Ù…Ø¬Ø§Ø² Ø§Ø³Øª"""
        if chat_type == 'private':
            allowed_commands = [cmd.command for cmd in PRIVATE_CHAT_COMMANDS]
        elif chat_type in ['group', 'supergroup']:
            allowed_commands = [cmd.command for cmd in GROUP_CHAT_COMMANDS]
        else:
            return False
        
        return command in allowed_commands

    # ==================== CHANNEL MEMBERSHIP CHECK ====================

    async def is_user_in_channel(self, user_id: int, context: ContextTypes.DEFAULT_TYPE) -> bool:
        """Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ø¶ÙˆÛŒØª Ú©Ø§Ø±Ø¨Ø± Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø§Ù„Ø²Ø§Ù…ÛŒ"""
        try:
            if not REQUIRED_CHANNEL:
                return True
            member = await context.bot.get_chat_member(REQUIRED_CHANNEL, user_id)
            if member.status in ["member", "administrator", "creator"]:
                return True
            return False
        except telegram.error.BadRequest as e:
            logger.error(f"Error checking membership for user {user_id}: {e}")
            return False
        except Exception as e:
            logger.error(f"Unexpected error checking channel membership: {e}")
            return False
    
    async def send_channel_join_message(self, update: Update) -> None:
        """Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¹Ø¶ÙˆÛŒØª Ø¯Ø± Ú©Ø§Ù†Ø§Ù„"""
        text = (
            f"ğŸ“¢ **Ø¹Ø¶ÙˆÛŒØª Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª!**\n\n"
            f"Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø±Ø¨Ø§ØªØŒ Ø§Ø¨ØªØ¯Ø§ Ø¨Ø§ÛŒØ¯ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø±Ø³Ù…ÛŒ Ù…Ø§ Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯:\n"
            f"ğŸ‘† **{REQUIRED_CHANNEL}**\n\n"
            f"ğŸ”¹ Ø±ÙˆÛŒ Ù„ÛŒÙ†Ú© Ø¨Ø§Ù„Ø§ Ú©Ù„ÛŒÚ© Ú©Ù†ÛŒØ¯\n"
            f"ğŸ”¹ Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯\n"
            f"ğŸ”¹ Ø³Ù¾Ø³ Ø¯ÙˆØ¨Ø§Ø±Ù‡ /start Ø¨Ø²Ù†ÛŒØ¯\n\n"
            f"âœ¨ Ø¨Ø§ Ø¹Ø¶ÙˆÛŒØª Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø§Ø² Ø¢Ø®Ø±ÛŒÙ† Ø§Ø®Ø¨Ø§Ø± Ùˆ Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒâ€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²ÛŒ Ø¨Ø§Ø®Ø¨Ø± Ø®ÙˆØ§Ù‡ÛŒØ¯ Ø´Ø¯!"
        )
        
        keyboard = [
            [InlineKeyboardButton("ğŸ“¢ Ø¹Ø¶ÙˆÛŒØª Ø¯Ø± Ú©Ø§Ù†Ø§Ù„", url=f"https://t.me/{REQUIRED_CHANNEL[1:]}")],
            [InlineKeyboardButton("ğŸ”„ Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ø¶ÙˆÛŒØª", callback_data="check_membership")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    # ==================== COMMAND HANDLERS ====================

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¯Ø³ØªÙˆØ± Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ"""
        user = update.effective_user
        
        # Check channel membership
        if not await self.is_user_in_channel(user.id, context):
            await self.send_channel_join_message(update)
            return
        
        # Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§: Ø¹Ø¯Ù… Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆØ› ÙÙ‚Ø· Ø§Ø·Ù„Ø§Ø¹â€ŒØ±Ø³Ø§Ù†ÛŒ ÛŒØ§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù¾Ù†Ù„â€ŒÙ‡Ø§ÛŒ ÙØ§ÛŒØª ÙØ¹Ø§Ù„
        if update.effective_chat.type in ['group', 'supergroup']:
            active = self.db.get_active_fight_for_group(update.effective_chat.id)
            if active:
                await update.message.reply_text("ğŸ¥Š ÛŒÚ© Ú†Ø§Ù„Ø´ ÙØ¹Ø§Ù„ Ø¯Ø± Ø§ÛŒÙ† Ú¯Ø±ÙˆÙ‡ Ø¬Ø±ÛŒØ§Ù† Ø¯Ø§Ø±Ø¯. Ø§Ø² Ù¾Ù†Ù„ Ù…ÙˆØ¬ÙˆØ¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.")
            else:
                await update.message.reply_text("â„¹ï¸ Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ Ø§Ø² Ù¾ÛŒÙˆÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†.")
            return

        # Ø®ØµÙˆØµÛŒ: Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆÛŒ Ø³Ø§Ø¯Ù‡â€ŒØ´Ø¯Ù‡ (Ø¨Ø¯ÙˆÙ† AI)
        player = self.db.get_or_create_player(
            user_id=user.id,
            username=user.username,
            first_name=user.first_name
        )
        player = self.game.check_and_reset_hearts(player)
        card_count = len(self.db.get_player_cards(user.id))

        welcome_text = (
            f"ğŸ® **Ø³Ù„Ø§Ù… {user.first_name}!**\n\n"
            f"Ø¨Ù‡ Ø¨Ø§Ø²ÛŒ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø´Ø®ØµÛŒØªâ€ŒÙ‡Ø§ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯!\n\n"
            f"ğŸ“Š **ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ:**\n"
            f"â¤ï¸ Ù‚Ù„Ø¨: {player.hearts}/{self.game.DAILY_HEARTS}\n"
            f"ğŸ´ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§: {card_count}\n"
            f"ğŸ† Ø§Ù…ØªÛŒØ§Ø²: {player.total_score}\n\n"
            f"Ú¯Ø²ÛŒÙ†Ù‡â€Œ Ù…ÙˆØ±Ø¯Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"
        )

        keyboard = [
            [InlineKeyboardButton("ğŸ´ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ù†", callback_data="my_cards")],
            [InlineKeyboardButton("âš”ï¸ Ú†Ø§Ù„Ø´ PvP", callback_data="request_pvp_fight")],
            [InlineKeyboardButton("ğŸ Ú©Ù„ÛŒÙ… Ø±ÙˆØ²Ø§Ù†Ù‡", callback_data="daily_claim")],
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(welcome_text, reply_markup=reply_markup, parse_mode='Markdown')

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø¨Ø§Ø²ÛŒ"""
        cfg_help = self.config.get('texts', {}).get('help')
        if cfg_help and isinstance(cfg_help, str) and cfg_help.strip():
            help_text = cfg_help
        else:
            help_text = (
                "ğŸ“– **Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ø¨Ø§Ø²ÛŒ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§**\n\n"
                "ğŸ¯ Ú©Ø§Ø±Øª Ø¬Ù…Ø¹ Ú©Ù†ØŒ Ù…Ø¨Ø§Ø±Ø²Ù‡ Ú©Ù†ØŒ Ø§Ù…ØªÛŒØ§Ø² Ø¨Ú¯ÛŒØ±!\n\n"
                "ğŸƒ Ø±Ø±ÛŒØªÛŒâ€ŒÙ‡Ø§: ğŸŸ¢ Normal â€¢ ğŸŸ£ Epic â€¢ ğŸŸ¡ Legend\n"
                f"ğŸ Ú©Ø§Ø±Øª Ø±ÙˆØ²Ø§Ù†Ù‡ Ù‡Ø± {self.game.CLAIM_COOLDOWN_HOURS} Ø³Ø§Ø¹Øª\n"
                "ğŸ¥Š PvP Ø¯Ø± Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§: Ú†Ø§Ù„Ø´ Ø¨Ø¯Ù‡ ÛŒØ§ Ù‚Ø¨ÙˆÙ„ Ú©Ù†\n"
                "âš™ï¸ Ø¯Ø± Ù…Ø³Ø§ÙˆÛŒ Ø§Ù…ØªÛŒØ§Ø²/Ù‚Ù„Ø¨ÛŒ Ú©Ù… ÛŒØ§ Ø²ÛŒØ§Ø¯ Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯\n"
            )
        
        if update.callback_query:
            keyboard = [[InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.callback_query.edit_message_text(
                help_text, reply_markup=reply_markup, parse_mode='Markdown'
            )
        else:
            await update.message.reply_text(help_text, parse_mode='Markdown')

    async def check_membership_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ø¶ÙˆÛŒØª Ú©Ø§Ø±Ø¨Ø± Ø¨Ø¹Ø¯ Ø§Ø² Ú©Ù„ÛŒÚ© Ø¯Ú©Ù…Ù‡"""
        query = update.callback_query
        await query.answer()
        
        user = query.from_user
        
        if await self.is_user_in_channel(user.id, context):
            # Ú©Ø§Ø±Ø¨Ø± Ø¹Ø¶Ùˆ Ø´Ø¯Ù‡ - Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ
            text = (
                f"âœ… **Ø¹Ø§Ù„ÛŒ! Ø´Ù…Ø§ Ø¨Ø§Ù…ÙˆÙÙ‚ÛŒØª Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø¹Ø¶Ùˆ Ø´Ø¯ÛŒØ¯.**\n\n"
                f"ğŸ‰ Ø®ÙˆØ´ Ø¢Ù…Ø¯ÛŒØ¯ {user.first_name}!\n"
                f"ğŸ® Ø­Ø§Ù„Ø§ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø§Ø² Ø±Ø¨Ø§Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯.\n\n"
                f"Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ /start Ø¨Ø²Ù†ÛŒØ¯."
            )
            keyboard = [[InlineKeyboardButton("ğŸ® Ø´Ø±ÙˆØ¹ Ø¨Ø§Ø²ÛŒ", callback_data="start_game")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
        else:
            # Ù‡Ù†ÙˆØ² Ø¹Ø¶Ùˆ Ù†Ø´Ø¯Ù‡
            await query.answer("âŒ Ù‡Ù†ÙˆØ² Ø¯Ø± Ú©Ø§Ù†Ø§Ù„ Ø¹Ø¶Ùˆ Ù†Ø´Ø¯Ù‡â€ŒØ§ÛŒØ¯. Ù„Ø·ÙØ§Ù‹ Ø§Ø¨ØªØ¯Ø§ Ø¹Ø¶Ùˆ Ø´ÙˆÛŒØ¯.", show_alert=True)

    async def profile_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù†Ù…Ø§ÛŒØ´ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ú©Ø§Ø±Ø¨Ø±"""
        # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¬ÙˆØ² Ø¯Ø³ØªÙˆØ±
        if not self._is_command_allowed_in_chat("profile", update.effective_chat.type):
            await update.message.reply_text(
                "ğŸš« Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± ÙÙ‚Ø· Ø¯Ø± Ú†Øª Ø®ØµÙˆØµÛŒ Ù‚Ø§Ø¨Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø³Øª.\n"
                "ğŸ“± Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø®ÙˆØ¯ØŒ Ø§Ø² Ù¾ÛŒÙˆÛŒ Ø±Ø¨Ø§Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯."
            )
            return
            
        user = update.effective_user
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ø¶ÙˆÛŒØª Ú©Ø§Ù†Ø§Ù„
        if not await self.is_user_in_channel(user.id, context):
            await self.send_channel_join_message(update)
            return

        player = self.db.get_or_create_player(user.id, user.username, user.first_name)
        player = self.game.check_and_reset_hearts(player)
        card_count = len(self.db.get_player_cards(user.id))
        stats = self.db.get_player_stats(user.id)

        text = (
            f"ğŸ‘¤ **Ù¾Ø±ÙˆÙØ§ÛŒÙ„ Ø´Ù…Ø§: {user.first_name}**\n\n"
            f"ğŸ“Š **Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒ:**\n"
            f"ğŸ† Ø§Ù…ØªÛŒØ§Ø² Ú©Ù„: {player.total_score}\n"
            f"â¤ï¸ Ù‚Ù„Ø¨ Ø¨Ø§Ù‚ÛŒâ€ŒÙ…Ø§Ù†Ø¯Ù‡: {player.hearts}/{self.game.DAILY_HEARTS}\n"
            f"ğŸ´ ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§: {card_count}\n\n"
            f"âš”ï¸ **Ø¢Ù…Ø§Ø± ÙØ§ÛŒØª:**\n"
            f"  - Ú©Ù„ Ø¨Ø§Ø²ÛŒâ€ŒÙ‡Ø§: {stats['games_played']}\n"
            f"  - Ø¨Ø±Ø¯: {stats['wins']}\n"
            f"  - Ø¨Ø§Ø®Øª: {stats['losses']}\n"
            f"  - Ù…Ø³Ø§ÙˆÛŒ: {stats['ties']}\n"
            f"  - Ù†Ø±Ø® Ø¨Ø±Ø¯: {int(stats['win_rate'])}%"
        )
        await update.message.reply_text(text, parse_mode='Markdown')

    async def cards_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø§Ø² Ø·Ø±ÛŒÙ‚ Ø¯Ø³ØªÙˆØ±"""
        # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¬ÙˆØ² Ø¯Ø³ØªÙˆØ±
        if not self._is_command_allowed_in_chat("cards", update.effective_chat.type):
            await update.message.reply_text(
                "ğŸš« Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± ÙÙ‚Ø· Ø¯Ø± Ú†Øª Ø®ØµÙˆØµÛŒ Ù‚Ø§Ø¨Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø³Øª.\n"
                "ğŸƒ Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø®ÙˆØ¯ØŒ Ø§Ø² Ù¾ÛŒÙˆÛŒ Ø±Ø¨Ø§Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯."
            )
            return
        
        user = update.effective_user
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ø¶ÙˆÛŒØª Ú©Ø§Ù†Ø§Ù„
        if not await self.is_user_in_channel(user.id, context):
            await self.send_channel_join_message(update)
            return
        
        user_id = update.effective_user.id
        cards = self.db.get_player_cards(user_id)
        
        if not cards:
            text = "ğŸ”­ Ù‡Ù†ÙˆØ² Ú©Ø§Ø±ØªÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯! Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ØŒ Ø¨Ø§ Ø¯Ø³ØªÙˆØ± /claim Ø§ÙˆÙ„ÛŒÙ† Ú©Ø§Ø±Øª Ø®ÙˆØ¯ Ø±Ø§ Ø±Ø§ÛŒÚ¯Ø§Ù† Ø¯Ø±ÛŒØ§ÙØª Ú©Ù†ÛŒØ¯."
            await update.message.reply_text(text)
        else:
            cards_by_rarity = {"legend": [], "epic": [], "normal": []}
            for card in cards:
                cards_by_rarity[card.rarity.value].append(card)
            
            text = f"ğŸ´ **Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø´Ù…Ø§ ({len(cards)} Ú©Ø§Ø±Øª):**\n\n"
            rarity_info = {
                "legend": ("ğŸŸ¡ **LEGEND**", CardRarity.LEGEND),
                "epic": ("ğŸŸ£ **EPIC**", CardRarity.EPIC),
                "normal": ("ğŸŸ¢ **NORMAL**", CardRarity.NORMAL)
            }
            
            for rarity_key, (rarity_text, rarity_enum) in rarity_info.items():
                cards_list = cards_by_rarity[rarity_key]
                if cards_list:
                    text += f"{rarity_text} ({len(cards_list)}):\n"
                    for card in cards_list:
                        stats = f"ğŸ’ª{card.power} âš¡{card.speed} ğŸ§ {card.iq} â¤ï¸{card.popularity}"
                        text += f"â€¢ {card.name} ({stats})\n"
                    text += "\n"
            
            await update.message.reply_text(text, parse_mode='Markdown')

    async def claim_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙˆØ± /claim"""
        user = update.effective_user
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ø¶ÙˆÛŒØª Ú©Ø§Ù†Ø§Ù„
        if not await self.is_user_in_channel(user.id, context):
            await self.send_channel_join_message(update)
            return
            
        user_id = user.id
        success, card, error = self.game.claim_daily_card(user_id)
        
        if success and card:
            rarity_colors = {
                CardRarity.NORMAL: "ğŸŸ¢",
                CardRarity.EPIC: "ğŸŸ£",
                CardRarity.LEGEND: "ğŸŸ¡"
            }
            color = rarity_colors[card.rarity]
            
            text = (
                f"ğŸ‰ **Ú©Ø§Ø±Øª Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯!**\n\n"
                f"{color} **{card.name}** ({card.rarity.value.title()})\n\n"
                f"ğŸ“Š **Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Øª:**\n"
                f"ğŸ’ª Ù‚Ø¯Ø±Øª: {card.power}\n"
                f"âš¡ Ø³Ø±Ø¹Øª: {card.speed}\n"
                f"ğŸ§  Ø¢ÛŒâ€ŒÚ©ÛŒÙˆ: {card.iq}\n"
                f"â¤ï¸ Ù…Ø­Ø¨ÙˆØ¨ÛŒØª: {card.popularity}\n"
            )
            await update.message.reply_text(text, parse_mode='Markdown')
            await send_card_image_safely(update.message, card.name, self.config, f"ğŸ‰ {card.name}")
        else:
            text = f"âš ï¸ **Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Øª**\n\n{error if error else 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ù…Ø´Ø®Øµ!'}"
            await update.message.reply_text(text, parse_mode='Markdown')

    async def leaderboard_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø³ØªÙˆØ± /leaderboard"""
        leaderboard = self.db.get_leaderboard(10)
        
        if not leaderboard:
            text = "ğŸ† **Ù„ÛŒØ¯Ø±Ø¨ÙˆØ±Ø¯ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª!**"
        else:
            text = "ğŸ† **Ù„ÛŒØ¯Ø±Ø¨ÙˆØ±Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø¨Ø±ØªØ±**\n\n"
            medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰", "4ï¸âƒ£", "5ï¸âƒ£", "6ï¸âƒ£", "7ï¸âƒ£", "8ï¸âƒ£", "9ï¸âƒ£", "ğŸ”Ÿ"]
            
            for i, player_info in enumerate(leaderboard):
                medal = medals[i] if i < len(medals) else f"{i+1}."
                name = player_info.get('first_name', 'Ø¨Ø§Ø²ÛŒÚ©Ù†')
                score = player_info.get('total_score', 0)
                text += f"{medal} **{name}** - {score} Ø§Ù…ØªÛŒØ§Ø²\n"
        
        await update.message.reply_text(text, parse_mode='Markdown')

    async def fight_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¯Ø³ØªÙˆØ± Ø´Ø±ÙˆØ¹ Ú†Ø§Ù„Ø´ PvP Ø¯Ø± Ú¯Ø±ÙˆÙ‡"""
        # Ø¨Ø±Ø±Ø³ÛŒ Ù…Ø¬ÙˆØ² Ø¯Ø³ØªÙˆØ±
        if not self._is_command_allowed_in_chat("fight", update.effective_chat.type):
            await update.message.reply_text(
                "ğŸš« Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± ÙÙ‚Ø· Ø¯Ø± Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§ Ù‚Ø§Ø¨Ù„ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø³Øª.\n"
                "ğŸ¥Š Ø¨Ø±Ø§ÛŒ Ú†Ø§Ù„Ø´ PvPØŒ Ø±Ø¨Ø§Øª Ø±Ø§ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯."
            )
            return

        challenger_id = update.effective_user.id
        chat_id = update.effective_chat.id

        player_cards = self.db.get_player_cards(challenger_id)
        if not player_cards:
            await update.message.reply_text("ğŸ´ Ø§Ø¨ØªØ¯Ø§ Ø¨Ø§ÛŒØ¯ Ú©Ø§Ø±ØªÛŒ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒØ¯! Ø¯Ø± Ú†Øª Ø®ØµÙˆØµÛŒ Ø±Ø¨Ø§Øª /start Ø¨Ø²Ù†ÛŒØ¯.")
            return

        active_fights = self.db.get_user_active_fights(challenger_id)
        if active_fights:
            await update.message.reply_text("âš ï¸ Ø´Ù…Ø§ Ù‚Ø¨Ù„Ø§Ù‹ ÛŒÚ© Ú†Ø§Ù„Ø´ ÙØ¹Ø§Ù„ Ø¯Ø§Ø±ÛŒØ¯.")
            return

        fight_id = self.db.create_fight(challenger_id, 0, chat_id)
        challenger_name = update.effective_user.first_name
        text = (
            f"ğŸ¥Š **Ú†Ø§Ù„Ø´ PvP!**\n\n"
            f"ğŸ”¥ {challenger_name} Ù‡Ù…Ù‡ Ø±Ø§ Ø¨Ù‡ Ù…Ø¨Ø§Ø±Ø²Ù‡ Ø¯Ø¹ÙˆØª Ù…ÛŒâ€ŒÚ©Ù†Ø¯!\n\n"
            f"Ø¢ÛŒØ§ Ø¬Ø±Ø¦Øª Ù‚Ø¨ÙˆÙ„ Ø§ÛŒÙ† Ú†Ø§Ù„Ø´ Ø±Ø§ Ø¯Ø§Ø±ÛŒØ¯ØŸ\n"
            f"ğŸ† Ø¨Ø±Ù†Ø¯Ù‡: +15 Ø§Ù…ØªÛŒØ§Ø²\n"
            f"âš¡ Ø¨Ø§Ø²Ù†Ø¯Ù‡: +1 Ø§Ù…ØªÛŒØ§Ø² ØªØ³Ù„ÛŒ"
        )
        keyboard = [
            [InlineKeyboardButton("âœŠ Ù‚Ø¨ÙˆÙ„ (Ù†Ø±Ù…Ø§Ù„)", callback_data=f"accept_pvp_{fight_id}")],
            [InlineKeyboardButton("ğŸ² Ù‚Ø¨ÙˆÙ„ (ØªØµØ§Ø¯ÙÛŒ)", callback_data=f"accept_pvp_random_{fight_id}")],
            [InlineKeyboardButton("ğŸ‘€ Ù„ÛŒØ¯Ø±Ø¨ÙˆØ±Ø¯", callback_data="leaderboard")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await context.bot.send_message(
            chat_id=chat_id,
            text=text,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )

    # ==================== PVP HANDLERS - FIXED ====================

    async def request_pvp_fight_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¯Ø±Ø®ÙˆØ§Ø³Øª ÙØ§ÛŒØª PvP"""
        query = update.callback_query
        await query.answer()
        
        if not ensure_not_expired(query, self.db, context):
            await query.answer("â° Ø§ÛŒÙ† Ù¾Ù†Ù„ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ /start Ø¨Ø²Ù†ÛŒØ¯.", show_alert=True)
            return
        
        challenger_id = query.from_user.id
        chat_id = query.message.chat_id
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ù†ÙˆØ¹ Ú†Øª - Ø¨Ø§ÛŒØ¯ Ú¯Ø±ÙˆÙ‡ Ø¨Ø§Ø´Ø¯
        if query.message.chat.type == 'private':
            text = "ğŸš« ÙØ§ÛŒØª PvP ÙÙ‚Ø· Ø¯Ø± Ú¯Ø±ÙˆÙ‡â€ŒÙ‡Ø§ Ø§Ù…Ú©Ø§Ù†â€ŒÙ¾Ø°ÛŒØ± Ø§Ø³Øª!\n\nÙ„Ø·ÙØ§Ù‹ Ø§ÛŒÙ† Ø±Ø¨Ø§Øª Ø±Ø§ Ø¨Ù‡ Ú¯Ø±ÙˆÙ‡ Ø§Ø¶Ø§ÙÙ‡ Ú©Ù†ÛŒØ¯."
            keyboard = [[InlineKeyboardButton("ğŸ”™ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="back_to_main")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(text, reply_markup=reply_markup)
            return
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ø´ØªÙ† Ú©Ø§Ø±Øª
        player_cards = self.db.get_player_cards(challenger_id)
        if not player_cards:
            text = "ğŸ´ **Ø§Ø¨ØªØ¯Ø§ Ø¨Ø§ÛŒØ¯ Ú©Ø§Ø±ØªÛŒ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒØ¯!**\n\nÙ„Ø·ÙØ§Ù‹ Ø§ÙˆÙ„ Ú©Ø§Ø±Øª Ø±Ø§ÛŒÚ¯Ø§Ù† Ø¯Ø±ÛŒØ§ÙØª Ú©Ù†ÛŒØ¯."
            keyboard = [
                [InlineKeyboardButton("ğŸ Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Øª Ø§ÙˆÙ„", callback_data="daily_claim")],
                [InlineKeyboardButton("ğŸ”™ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="back_to_main")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            return
        
        # Ø¨Ø±Ø±Ø³ÛŒ ÙØ§ÛŒØªâ€ŒÙ‡Ø§ÛŒ ÙØ¹Ø§Ù„
        active_fights = self.db.get_user_active_fights(challenger_id)
        if active_fights:
            text = (
                "âš ï¸ **Ø´Ù…Ø§ Ù‚Ø¨Ù„Ø§Ù‹ Ú†Ø§Ù„Ø´ ÙØ¹Ø§Ù„ÛŒ Ø¯Ø§Ø±ÛŒØ¯!**\n\n"
                "Ù„Ø·ÙØ§Ù‹ ÙØ§ÛŒØª ÙØ¹Ù„ÛŒ Ø±Ø§ Ú©Ø§Ù…Ù„ Ú©Ù†ÛŒØ¯ ÛŒØ§ Ù…Ù†ØªØ¸Ø± Ø§Ù†Ù‚Ø¶Ø§ÛŒ Ø¢Ù† Ø¨Ø§Ø´ÛŒØ¯."
            )
            keyboard = [[InlineKeyboardButton("ğŸ”™ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="back_to_main")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            return
        
        # Ø§ÛŒØ¬Ø§Ø¯ ÙØ§ÛŒØª Ø¬Ø¯ÛŒØ¯ - Ø§Ø¨ØªØ¯Ø§ ÙÙ‚Ø· challenger_id
        fight_id = self.db.create_fight(challenger_id, 0, chat_id)  # opponent_id Ù…ÙˆÙ‚ØªØ§Ù‹ 0
        
        challenger_name = query.from_user.first_name
        text = (
            f"ğŸ¥Š **Ú†Ø§Ù„Ø´ PvP!**\n\n"
            f"ğŸ”¥ {challenger_name} Ù‡Ù…Ù‡ Ø±Ø§ Ø¨Ù‡ Ù…Ø¨Ø§Ø±Ø²Ù‡ Ø¯Ø¹ÙˆØª Ù…ÛŒâ€ŒÚ©Ù†Ø¯!\n\n"
            f"Ø¢ÛŒØ§ Ø¬Ø±Ø¦Øª Ù‚Ø¨ÙˆÙ„ Ø§ÛŒÙ† Ú†Ø§Ù„Ø´ Ø±Ø§ Ø¯Ø§Ø±ÛŒØ¯ØŸ\n"
            f"ğŸ† Ø¨Ø±Ù†Ø¯Ù‡: +15 Ø§Ù…ØªÛŒØ§Ø²\n"
            f"âš¡ Ø¨Ø§Ø²Ù†Ø¯Ù‡: +1 Ø§Ù…ØªÛŒØ§Ø² ØªØ³Ù„ÛŒ"
        )
        
        keyboard = [
            [InlineKeyboardButton("âœŠ Ù‚Ø¨ÙˆÙ„ (Ù†Ø±Ù…Ø§Ù„)", callback_data=f"accept_pvp_{fight_id}")],
            [InlineKeyboardButton("ğŸ² Ù‚Ø¨ÙˆÙ„ (ØªØµØ§Ø¯ÙÛŒ)", callback_data=f"accept_pvp_random_{fight_id}")],
            [InlineKeyboardButton("ğŸ‘€ Ù„ÛŒØ¯Ø±Ø¨ÙˆØ±Ø¯", callback_data="leaderboard")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        # Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø¯Ø± Ú¯Ø±ÙˆÙ‡
        await context.bot.send_message(
            chat_id=chat_id,
            text=text,
            reply_markup=reply_markup,
            parse_mode='Markdown'
        )
        
        # ØªØ§ÛŒÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ú†Ù„Ù†Ø¬Ø±
        await query.edit_message_text(
            "âœ… **Ú†Ø§Ù„Ø´ Ø´Ù…Ø§ Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯!**\n\nÙ…Ù†ØªØ¸Ø± Ù‚Ø¨ÙˆÙ„ Ú†Ø§Ù„Ø´ Ø¯Ø± Ú¯Ø±ÙˆÙ‡ Ø¨Ø§Ø´ÛŒØ¯...",
            parse_mode='Markdown'
        )

    async def accept_pvp_fight_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù‚Ø¨ÙˆÙ„ Ú†Ø§Ù„Ø´ PvP - FIXED"""
        query = update.callback_query
        await query.answer()
        
        
        fight_id = query.data.split("_")[-1]
        opponent_id = query.from_user.id
        
        logger.info(f"Accept PvP - Data: {query.data}, User: {opponent_id}")
        
        # Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒØª
        fight = self.db.get_fight_by_id(fight_id)
        if not fight:
            await query.answer("âŒ Ú†Ø§Ù„Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯ ÛŒØ§ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡!", show_alert=True)
            return
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ challenger Ø®ÙˆØ¯Ø´ Ù†Ù¾Ø°ÛŒØ±Ø¯
        if fight.challenger_id == opponent_id:
            await query.answer("âŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ú†Ø§Ù„Ø´ Ø®ÙˆØ¯ØªØ§Ù† Ø±Ø§ Ø¨Ù¾Ø°ÛŒØ±ÛŒØ¯!", show_alert=True)
            return
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø¯Ø§Ø´ØªÙ† Ú©Ø§Ø±Øª
        opponent_cards = self.db.get_player_cards(opponent_id)
        if not opponent_cards:
            await query.answer("âŒ Ø§Ø¨ØªØ¯Ø§ Ú©Ø§Ø±ØªÛŒ Ø¨Ø§ÛŒØ¯ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒØ¯! Ø¯Ø± Ø®ØµÙˆØµÛŒ /start Ø¨Ø²Ù†ÛŒØ¯.", show_alert=True)
            return
        
        # Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª ÙØ§ÛŒØª
        if fight.status != FightStatus.WAITING_FOR_OPPONENT:
            await query.answer("âŒ Ø§ÛŒÙ† Ú†Ø§Ù„Ø´ Ø¯ÛŒÚ¯Ø± Ù‚Ø§Ø¨Ù„ Ù‚Ø¨ÙˆÙ„ Ù†ÛŒØ³Øª!", show_alert=True)
            return
        
        # Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§ØªÙ…ÛŒ Ø¬Ù‡Øª Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ø´Ø±Ø§ÛŒØ· Ø±Ù‚Ø§Ø¨ØªÛŒ
        claimed = self.db.claim_opponent_if_waiting(fight_id, opponent_id)
        if not claimed:
            await query.answer("âŒ Someone already joined or fight is no longer valid.", show_alert=True)
            return
        # ØªÙ…Ø¯ÛŒØ¯ Ù…Ù‡Ù„Øª ÙØ§ÛŒØª Ø¨Ù‡ Ù…Ø¯Øª 15 Ø¯Ù‚ÛŒÙ‚Ù‡ Ù¾Ø³ Ø§Ø² Ù¾Ø°ÛŒØ±Ø´
        try:
            new_expiry = datetime.now() + timedelta(minutes=15)
            self.db.update_fight(fight_id, expires_at=new_expiry.isoformat())
        except Exception as e:
            logger.warning(f"Failed to extend fight {fight_id} expiry: {e}")
        
        # Ø¯Ø±ÛŒØ§ÙØª Ù†Ø§Ù… Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†
        challenger = self.db.get_or_create_player(fight.challenger_id)
        opponent = self.db.get_or_create_player(opponent_id)
        
        # Ù„ÛŒÙ†Ú© Ù¾ÛŒÙˆÛŒ Ø±Ø¨Ø§Øª
        bot_link = "@TelBattleBot"
        
        # Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ù‚Ø¨ÙˆÙ„ÛŒ Ø¯Ø± Ú¯Ø±ÙˆÙ‡
        text = (
            f"âš”ï¸ **ÙØ§ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯!**\n\n"
            f"ğŸ”¥ {challenger.first_name} ğŸ†š {opponent.first_name}\n\n"
            f"Ù‡Ø± Ø¯Ùˆ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¯Ø± Ù¾ÛŒØ§Ù… Ø®ØµÙˆØµÛŒ Ú©Ø§Ø±Øª Ùˆ ÙˆÛŒÚ˜Ú¯ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯.\n"
            f"ğŸ‘† **Ø¨Ø±Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ø±Øª:** {bot_link}\n"
            f"â° Ù…Ù‡Ù„Øª: 15 Ø¯Ù‚ÛŒÙ‚Ù‡"
        )
        
        keyboard = [[InlineKeyboardButton("ğŸ† Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù„ÛŒØ¯Ø±Ø¨ÙˆØ±Ø¯", callback_data="leaderboard")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')
        
        # Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø®ØµÙˆØµÛŒ Ø¨Ù‡ challenger
        try:
            await context.bot.send_message(
                chat_id=fight.challenger_id,
                text=f"âœ… **{opponent.first_name} Ú†Ø§Ù„Ø´ Ø´Ù…Ø§ Ø±Ø§ Ù¾Ø°ÛŒØ±ÙØª!**\n\nÙ„Ø·ÙØ§Ù‹ Ú©Ø§Ø±Øª Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
                reply_markup=self._create_pvp_card_selection_keyboard(fight_id, fight.challenger_id),
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.warning(f"Could not send private message to challenger {fight.challenger_id}: {e}")
        
        # Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø®ØµÙˆØµÛŒ Ø¨Ù‡ opponent
        try:
            await context.bot.send_message(
                chat_id=opponent_id,
                text=f"âœ… **Ø´Ù…Ø§ Ú†Ø§Ù„Ø´ {challenger.first_name} Ø±Ø§ Ù¾Ø°ÛŒØ±ÙØªÛŒØ¯!**\n\nÙ„Ø·ÙØ§Ù‹ Ú©Ø§Ø±Øª Ø®ÙˆØ¯ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
                reply_markup=self._create_pvp_card_selection_keyboard(fight_id, opponent_id),
                parse_mode='Markdown'
            )
        except Exception as e:
            logger.warning(f"Could not send private message to opponent {opponent_id}: {e}")

    async def accept_pvp_random_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù‚Ø¨ÙˆÙ„ Ú†Ø§Ù„Ø´ PvP Ø¨Ù‡ ØµÙˆØ±Øª ØªØµØ§Ø¯ÙÛŒ (Ø§Ù†ØªØ®Ø§Ø¨ Ø®ÙˆØ¯Ú©Ø§Ø± Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§)"""
        query = update.callback_query
        await query.answer()

        fight_id = query.data.split("_")[-1]
        opponent_id = query.from_user.id

        fight = self.db.get_fight_by_id(fight_id)
        if not fight or fight.status != FightStatus.WAITING_FOR_OPPONENT:
            await query.answer("âŒ Ø§ÛŒÙ† Ú†Ø§Ù„Ø´ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª!", show_alert=True)
            return
        if fight.challenger_id == opponent_id:
            await query.answer("âŒ Ù†Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ú†Ø§Ù„Ø´ Ø®ÙˆØ¯ØªØ§Ù† Ø±Ø§ Ø¨Ù¾Ø°ÛŒØ±ÛŒØ¯!", show_alert=True)
            return

        # ØªÙ†Ø¸ÛŒÙ… Ø­Ø±ÛŒÙ Ø¨Ù‡ ØµÙˆØ±Øª Ø§ØªÙ…ÛŒ
        claimed = self.db.claim_opponent_if_waiting(fight_id, opponent_id)
        if not claimed:
            await query.answer("âŒ Someone already joined or fight is no longer valid.", show_alert=True)
            return

        # Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ø±Øª ØªØµØ§Ø¯ÙÛŒ Ø¨Ø±Ø§ÛŒ Ù‡Ø± Ø¨Ø§Ø²ÛŒÚ©Ù† Ø§Ø² Ø¯Ú©
        challenger_cards = self.db.get_player_cards(fight.challenger_id)
        opponent_cards = self.db.get_player_cards(opponent_id)
        if not challenger_cards or not opponent_cards:
            await query.answer("âŒ Ù‡Ø± Ø¯Ùˆ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø¨Ø§ÛŒØ¯ Ú©Ø§Ø±Øª Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´Ù†Ø¯!", show_alert=True)
            return
        ch_card = random.choice(challenger_cards)
        op_card = random.choice(opponent_cards)

        self.db.update_fight(fight_id, challenger_card_id=ch_card.card_id, opponent_card_id=op_card.card_id)

        # Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ø®ØµÙˆØµÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ ÙˆÛŒÚ˜Ú¯ÛŒâ€ŒÙ‡Ø§
        try:
            await context.bot.send_message(
                chat_id=fight.challenger_id,
                text=f"ğŸ² Ú©Ø§Ø±Øª Ø´Ù…Ø§ Ø¨Ù‡ ØµÙˆØ±Øª ØªØµØ§Ø¯ÙÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯: {ch_card.name}\nÙˆÛŒÚ˜Ú¯ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
                reply_markup=self._create_stat_selection_keyboard(fight_id, ch_card)
            )
        except Exception as e:
            logger.warning(f"PM to challenger failed: {e}")
        try:
            await context.bot.send_message(
                chat_id=opponent_id,
                text=f"ğŸ² Ú©Ø§Ø±Øª Ø´Ù…Ø§ Ø¨Ù‡ ØµÙˆØ±Øª ØªØµØ§Ø¯ÙÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯: {op_card.name}\nÙˆÛŒÚ˜Ú¯ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:",
                reply_markup=self._create_stat_selection_keyboard(fight_id, op_card)
            )
        except Exception as e:
            logger.warning(f"PM to opponent failed: {e}")

        # Ø§Ø·Ù„Ø§Ø¹ Ø¯Ø± Ú¯Ø±ÙˆÙ‡
        try:
            await query.edit_message_text(
                "âœ… ÙØ§ÛŒØª ØªØµØ§Ø¯ÙÛŒ ØªØ§ÛŒÛŒØ¯ Ø´Ø¯! Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø¯Ø± Ø®ØµÙˆØµÛŒ ÙˆÛŒÚ˜Ú¯ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†Ù†Ø¯.",
                parse_mode='Markdown'
            )
        except Exception:
            pass

    def _create_pvp_card_selection_keyboard(self, fight_id: str, user_id: int) -> InlineKeyboardMarkup:
        """Ø§ÛŒØ¬Ø§Ø¯ Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ø±Øª Ø¨Ø±Ø§ÛŒ PvP"""
        cards = self.db.get_player_cards(user_id)
        keyboard = []
        
        max_cards = min(len(cards), self.config['game_settings']['max_cards_per_page'])
        
        for card in cards[:max_cards]:
            rarity_colors = {
                CardRarity.NORMAL: "ğŸŸ¢",
                CardRarity.EPIC: "ğŸŸ£", 
                CardRarity.LEGEND: "ğŸŸ¡"
            }
            color = rarity_colors[card.rarity]
            stats = f"ğŸ’ª{card.power} âš¡{card.speed} ğŸ§ {card.iq} â¤ï¸{card.popularity}"
            
            keyboard.append([
                InlineKeyboardButton(
                    f"{color} {card.name} ({stats})",
                    callback_data=f"pvp_card_{fight_id}_{card.card_id}"
                )
            ])
        
        return InlineKeyboardMarkup(keyboard)

    def _create_stat_selection_keyboard(self, fight_id: str, card: Card) -> InlineKeyboardMarkup:
        keyboard = [
            [InlineKeyboardButton(f"ğŸ’ª Ù‚Ø¯Ø±Øª ({card.power})", callback_data=f"pvp_stat_{fight_id}_power")],
            [InlineKeyboardButton(f"âš¡ Ø³Ø±Ø¹Øª ({card.speed})", callback_data=f"pvp_stat_{fight_id}_speed")],
            [InlineKeyboardButton(f"ğŸ§  Ø¢ÛŒâ€ŒÚ©ÛŒÙˆ ({card.iq})", callback_data=f"pvp_stat_{fight_id}_iq")],
            [InlineKeyboardButton(f"â¤ï¸ Ù…Ø­Ø¨ÙˆØ¨ÛŒØª ({card.popularity})", callback_data=f"pvp_stat_{fight_id}_popularity")]
        ]
        return InlineKeyboardMarkup(keyboard)

    async def pvp_card_select_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ø±Øª Ø¯Ø± ÙØ§ÛŒØª PvP - FIXED"""
        query = update.callback_query
        await query.answer()

        
        parts = query.data.split("_")
        fight_id = parts[2]
        card_id = parts[3]
        user_id = query.from_user.id
        
        # Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒØª
        fight = self.db.get_fight_by_id(fight_id)
        logger.info(f"PvP Card Select - Data: {query.data}, User: {user_id}")
        if fight:
            logger.info(f"Fight before update: challenger={fight.challenger_id}, opponent={fight.opponent_id}")
        else:
            logger.warning(f"Fight {fight_id} not found at card select!")    
            
        if not fight:
            text = "âŒ ÙØ§ÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯!"
            await query.edit_message_text(text)
            return
        
        # ØªØ¹ÛŒÛŒÙ† Ø§ÛŒÙ†Ú©Ù‡ Ú©Ø§Ø±Ø¨Ø± challenger Ø§Ø³Øª ÛŒØ§ opponent
        if user_id == fight.challenger_id:
            field_name = "challenger_card_id"
        elif user_id == fight.opponent_id:
            field_name = "opponent_card_id"
        else:
            await query.answer("âŒ Ø´Ù…Ø§ Ø¨Ø®Ø´ÛŒ Ø§Ø² Ø§ÛŒÙ† ÙØ§ÛŒØª Ù†ÛŒØ³ØªÛŒØ¯!", show_alert=True)
            return
        
        # Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ø±Øª
        update_data = {field_name: card_id}
        
        # Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ ÙØ§ÛŒØª Ø¨Ø±Ø§ÛŒ ØªØ¹ÛŒÛŒÙ† ÙˆØ¶Ø¹ÛŒØª Ù…ÛŒØ§Ù†ÛŒ ÛŒØ§ Ù†Ù‡Ø§ÛŒÛŒ
        current_fight = self.db.get_fight_by_id(fight_id)
        
        # Ø§Ú¯Ø± Ø§ÙˆÙ„ÛŒÙ† Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ø±Øª ØªÙˆØ³Ø· Ú†Ù„Ù†Ø¬Ø± Ø§Ø³Øª Ùˆ Ø­Ø±ÛŒÙ Ù‡Ù†ÙˆØ² Ú©Ø§Ø±Øª Ù†Ø¯Ø§Ø±Ø¯
        if user_id == fight.challenger_id and not current_fight.opponent_card_id:
            update_data["status"] = FightStatus.CHALLENGER_CARD_SELECTED
        # Ø§Ú¯Ø± Ø§ÙˆÙ„ÛŒÙ† Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ø±Øª ØªÙˆØ³Ø· Ø­Ø±ÛŒÙ Ø§Ø³Øª Ùˆ Ú†Ù„Ù†Ø¬Ø± Ù‡Ù†ÙˆØ² Ú©Ø§Ø±Øª Ù†Ø¯Ø§Ø±Ø¯
        if user_id == fight.opponent_id and not current_fight.challenger_card_id:
            update_data["status"] = FightStatus.OPPONENT_CARD_SELECTED
        
        # Ø§Ú¯Ø± Ø¨Ø§ Ø§ÛŒÙ† Ø§Ù†ØªØ®Ø§Ø¨ Ù‡Ø± Ø¯Ùˆ Ú©Ø§Ø±Øª Ù…ÙˆØ¬ÙˆØ¯ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ØŒ ÙˆØ¶Ø¹ÛŒØª Ø±Ø§ Ø¨Ù‡ BOTH_CARDS_SELECTED Ø§Ø±ØªÙ‚Ø§ Ø¨Ø¯Ù‡
        if user_id == fight.challenger_id and current_fight.opponent_card_id:
            update_data["status"] = FightStatus.BOTH_CARDS_SELECTED
        elif user_id == fight.opponent_id and current_fight.challenger_card_id:
            update_data["status"] = FightStatus.BOTH_CARDS_SELECTED
        
        self.db.update_fight(fight_id, **update_data)
        
        # Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Øª Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯Ù‡
        selected_card = self.db.get_card_by_id(card_id)
        # Ø¨Ø§Ø²Ø®ÙˆØ±Ø¯ Ø³Ø±ÛŒØ¹ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±
        try:
            await query.answer("âœ… Card selected!")
        except Exception:
            pass
        
        text = (
            f"âœ… **Ú©Ø§Ø±Øª Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯!**\n\n"
            f"ğŸ´ {selected_card.name}\n\n"
            f"Ø­Ø§Ù„Ø§ ÙˆÛŒÚ˜Ú¯ÛŒ Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø¨Ø±Ø§ÛŒ ÙØ§ÛŒØª Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"
        )
        
        keyboard = [
            [InlineKeyboardButton(f"ğŸ’ª Ù‚Ø¯Ø±Øª ({selected_card.power})", callback_data=f"pvp_stat_{fight_id}_power")],
            [InlineKeyboardButton(f"âš¡ Ø³Ø±Ø¹Øª ({selected_card.speed})", callback_data=f"pvp_stat_{fight_id}_speed")],
            [InlineKeyboardButton(f"ğŸ§  Ø¢ÛŒâ€ŒÚ©ÛŒÙˆ ({selected_card.iq})", callback_data=f"pvp_stat_{fight_id}_iq")],
            [InlineKeyboardButton(f"â¤ï¸ Ù…Ø­Ø¨ÙˆØ¨ÛŒØª ({selected_card.popularity})", callback_data=f"pvp_stat_{fight_id}_popularity")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    async def pvp_stat_select_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø§Ù†ØªØ®Ø§Ø¨ ÙˆÛŒÚ˜Ú¯ÛŒ Ø¯Ø± ÙØ§ÛŒØª PvP - COMPLETELY FIXED"""
        query = update.callback_query
        await query.answer()
        
        parts = query.data.split("_")
        fight_id = parts[2]
        stat = parts[3]
        user_id = query.from_user.id
        
        logger.info(f"PvP Stat Select - Fight: {fight_id}, User: {user_id}, Stat: {stat}")
        
        # Ø¯Ø±ÛŒØ§ÙØª ÙØ§ÛŒØª
        fight = self.db.get_fight_by_id(fight_id)
        if not fight:
            text = "âŒ ÙØ§ÛŒØª ÛŒØ§ÙØª Ù†Ø´Ø¯!"
            await query.edit_message_text(text)
            logger.error(f"Fight {fight_id} not found")
            return
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø§ÙˆÙ„ÛŒÙ‡ opponent_id
        if self.db.is_unclaimed(fight):
            logger.error(f"Fight {fight_id} has invalid opponent_id=0")
            await query.answer("âŒ Ø®Ø·Ø§: Ø­Ø±ÛŒÙ Ù…Ø¹ØªØ¨Ø± Ù†ÛŒØ³Øª!", show_alert=True)
            return
        
        # ØªØ¹ÛŒÛŒÙ† Ø§ÛŒÙ†Ú©Ù‡ Ú©Ø§Ø±Ø¨Ø± challenger Ø§Ø³Øª ÛŒØ§ opponent
        if user_id == fight.challenger_id:
            field_name = "challenger_stat"
            user_role = "challenger"
        elif user_id == fight.opponent_id:
            field_name = "opponent_stat"
            user_role = "opponent"
        else:
            await query.answer("âŒ Ø´Ù…Ø§ Ø¨Ø®Ø´ÛŒ Ø§Ø² Ø§ÛŒÙ† ÙØ§ÛŒØª Ù†ÛŒØ³ØªÛŒØ¯!", show_alert=True)
            logger.warning(f"User {user_id} tried to select stat for fight {fight_id} but is not participant")
            return
        
        logger.info(f"User {user_id} is {user_role} selecting stat {stat}")
        
        # Ø¨Ø±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ ÙˆÛŒÚ˜Ú¯ÛŒ
        update_data = {field_name: stat}
        success = self.db.update_fight(fight_id, **update_data)
        
        if not success:
            logger.error(f"Failed to update fight {fight_id} with {field_name}={stat}")
            await query.answer("âŒ Ø®Ø·Ø§ Ø¯Ø± Ø°Ø®ÛŒØ±Ù‡ Ø§Ù†ØªØ®Ø§Ø¨!", show_alert=True)
            return
        
        # Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª Ø¨Ù‡â€ŒØ±ÙˆØ²Ø´Ø¯Ù‡
        updated_fight = self.db.get_fight_by_id(fight_id)
        if not updated_fight:
            logger.error(f"Fight {fight_id} disappeared after update")
            await query.answer("âŒ Ø®Ø·Ø§ÛŒ Ø³ÛŒØ³ØªÙ…ÛŒ!", show_alert=True)
            return
        
        # Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ ÙˆÛŒÚ˜Ú¯ÛŒ Ø¨Ø±Ø§ÛŒ Ù†Ù…Ø§ÛŒØ´
        stat_names = {
            "power": "ğŸ’ª Ù‚Ø¯Ø±Øª",
            "speed": "âš¡ Ø³Ø±Ø¹Øª",
            "iq": "ğŸ§  Ø¢ÛŒâ€ŒÚ©ÛŒÙˆ",
            "popularity": "â¤ï¸ Ù…Ø­Ø¨ÙˆØ¨ÛŒØª"
        }
        
        selected_stat_name = stat_names.get(stat, f"ÙˆÛŒÚ˜Ú¯ÛŒ {stat}")
        
        logger.info(f"Fight {fight_id} status after update: "
                    f"challenger_stat={updated_fight.challenger_stat}, "
                    f"opponent_stat={updated_fight.opponent_stat}")
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ Ù‡Ø± Ø¯Ùˆ Ø¨Ø§Ø²ÛŒÚ©Ù† Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯Ù‡â€ŒØ§Ù†Ø¯
        if updated_fight.challenger_stat and updated_fight.opponent_stat:
            # Ø¨Ø§Ø²Ø®ÙˆØ±Ø¯ Ø³Ø±ÛŒØ¹
            try:
                await query.answer("âš”ï¸ Both stats selected! Resolving fight...")
            except Exception:
                pass
            # Ù‡Ø± Ø¯Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯Ù‡â€ŒØ§Ù†Ø¯ - Ø¨Ø§ÛŒØ¯ ÙØ§ÛŒØª Ø­Ù„ Ø´ÙˆØ¯
            logger.info(f"Both players selected stats for fight {fight_id} - resolving")
            
            # Ø§Ø¹Ù„Ø§Ù… Ø´Ø±ÙˆØ¹ Ù…Ø­Ø§Ø³Ø¨Ù‡
            text = f"âœ… **{selected_stat_name} Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯!**\n\nâš”ï¸ Ø¯Ø±Ø­Ø§Ù„ Ù…Ø­Ø§Ø³Ø¨Ù‡ Ù†ØªÛŒØ¬Ù‡ ÙØ§ÛŒØª..."
            await query.edit_message_text(text, parse_mode='Markdown')
            
            # Ø­Ù„ ÙØ§ÛŒØª
            try:
                result = self.game.resolve_pvp_fight(fight_id)
                
                if result.get("success"):
                    logger.info(f"Fight {fight_id} resolved successfully")
                    await self._announce_pvp_result(context, result)
                else:
                    error_msg = result.get("error", "Ø®Ø·Ø§ÛŒ Ù†Ø§Ù…Ø´Ø®Øµ Ø¯Ø± Ø­Ù„ ÙØ§ÛŒØª")
                    logger.error(f"Fight {fight_id} resolution failed: {error_msg}")
                    
                    # Ø§Ø·Ù„Ø§Ø¹ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¯Ø± ØµÙˆØ±Øª Ø®Ø·Ø§
                    if updated_fight.chat_id:
                        error_text = (
                            f"âŒ **Ø®Ø·Ø§ Ø¯Ø± ÙØ§ÛŒØª!**\n\n"
                            f"Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ ÙØ§ÛŒØª Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ Ø®Ø·Ø§ÛŒ Ø²ÛŒØ± Ù„ØºÙˆ Ø´Ø¯:\n"
                            f"`{error_msg}`\n\n"
                            f"Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯."
                        )
                        try:
                            await context.bot.send_message(
                                chat_id=updated_fight.chat_id,
                                text=error_text,
                                parse_mode='Markdown'
                            )
                        except Exception as e:
                            logger.error(f"Failed to send error message to chat {updated_fight.chat_id}: {e}")
                    
                    # Ø­Ø°Ù ÙØ§ÛŒØª Ù†Ø§Ù‚Øµ Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³
                    self.db.delete_fight(fight_id)
                    
            except Exception as e:
                logger.error(f"Exception in fight {fight_id} resolution: {e}", exc_info=True)
                
                # Ø§Ø·Ù„Ø§Ø¹ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø¯Ø± ØµÙˆØ±Øª Ø®Ø·Ø§ÛŒ Ø³ÛŒØ³ØªÙ…ÛŒ
                if updated_fight.chat_id:
                    system_error_text = (
                        f"ğŸ’¥ **Ø®Ø·Ø§ÛŒ Ø³ÛŒØ³ØªÙ…ÛŒ!**\n\n"
                        f"Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ ÙØ§ÛŒØª Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ Ø®Ø·Ø§ÛŒ Ø³ÛŒØ³ØªÙ…ÛŒ Ù„ØºÙˆ Ø´Ø¯.\n"
                        f"Ù„Ø·ÙØ§Ù‹ Ú†Ù†Ø¯ Ø¯Ù‚ÛŒÙ‚Ù‡ Ø¯ÛŒÚ¯Ø± Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯."
                    )
                    try:
                        await context.bot.send_message(
                            chat_id=updated_fight.chat_id,
                            text=system_error_text,
                            parse_mode='Markdown'
                        )
                    except Exception as send_error:
                        logger.error(f"Failed to send system error message: {send_error}")
                
                # Ø­Ø°Ù ÙØ§ÛŒØª Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³
                self.db.delete_fight(fight_id)
        
        else:
            # ÙÙ‚Ø· ÛŒÚ©ÛŒ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø±Ø¯Ù‡ - Ù…Ù†ØªØ¸Ø± Ø¯ÛŒÚ¯Ø±ÛŒ
            logger.info(f"Fight {fight_id}: Only {user_role} selected stat, waiting for other player")
            
            try:
                await query.answer("âœ… Stat selected! Waiting for opponent â³")
            except Exception:
                pass

            text = (
                f"âœ… **{selected_stat_name} Ø§Ù†ØªØ®Ø§Ø¨ Ø´Ø¯!**\n\n"
                f"â³ Ù…Ù†ØªØ¸Ø± Ø§Ù†ØªØ®Ø§Ø¨ Ø­Ø±ÛŒÙ...\n\n"
                f"Ù†ØªÛŒØ¬Ù‡ ÙØ§ÛŒØª Ø¯Ø± Ú¯Ø±ÙˆÙ‡ Ø§Ø¹Ù„Ø§Ù… Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯."
            )
            await query.edit_message_text(text, parse_mode='Markdown')

    async def _announce_pvp_result(self, context: ContextTypes.DEFAULT_TYPE, result: Dict):
        """Ø§Ø¹Ù„Ø§Ù… Ù†ØªÛŒØ¬Ù‡ ÙØ§ÛŒØª PvP Ø¯Ø± Ú¯Ø±ÙˆÙ‡"""
        try:
            fight_id = result["fight_id"]
            fight = self.db.get_fight_by_id(fight_id)
            
            if not fight or not fight.chat_id:
                logger.error(f"Cannot announce PvP result: fight {fight_id} not found or no chat_id")
                return
            
            challenger_data = result["challenger"]
            opponent_data = result["opponent"]
            result_type = result["result_type"]
            
            # Ø¯Ø±ÛŒØ§ÙØª Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù†
            challenger = self.db.get_or_create_player(challenger_data["user_id"])
            opponent = self.db.get_or_create_player(opponent_data["user_id"])
            
            # Ø§ÛŒÙ…ÙˆØ¬ÛŒâ€ŒÙ‡Ø§ÛŒ Ú©Ù…ÛŒØ§Ø¨ÛŒ
            rarity_colors = {
                CardRarity.NORMAL: "ğŸŸ¢",
                CardRarity.EPIC: "ğŸŸ£",
                CardRarity.LEGEND: "ğŸŸ¡"
            }
            
            challenger_color = rarity_colors[challenger_data["card"].rarity]
            opponent_color = rarity_colors[opponent_data["card"].rarity]
            
            # Ù†Ø§Ù…â€ŒÙ‡Ø§ÛŒ ÙˆÛŒÚ˜Ú¯ÛŒ
            stat_names = {
                "power": "Ù‚Ø¯Ø±Øª ğŸ’ª",
                "speed": "Ø³Ø±Ø¹Øª âš¡",
                "iq": "Ø¢ÛŒâ€ŒÚ©ÛŒÙˆ ğŸ§ ",
                "popularity": "Ù…Ø­Ø¨ÙˆØ¨ÛŒØª â¤ï¸"
            }
            
            # Ø¹Ù†ÙˆØ§Ù† Ù†ØªÛŒØ¬Ù‡
            if result_type == "challenger_wins":
                result_text = f"ğŸ† **{challenger.first_name} Ù¾ÛŒØ±ÙˆØ² Ø´Ø¯!**"
                result_emoji = "ğŸ‰"
            elif result_type == "opponent_wins":
                result_text = f"ğŸ† **{opponent.first_name} Ù¾ÛŒØ±ÙˆØ² Ø´Ø¯!**"
                result_emoji = "ğŸ‰"
            else:
                result_text = "ğŸ¤ **Ù…Ø³Ø§ÙˆÛŒ!**"
                result_emoji = "ğŸ¤"
            
            # Ø³Ø§Ø®Øª Ù…ØªÙ† Ù†ØªÛŒØ¬Ù‡
            text = (
                f"âš”ï¸ **Ù†ØªÛŒØ¬Ù‡ ÙØ§ÛŒØª PvP**\n\n"
                f"{result_text}\n\n"
                f"ğŸ“Š **Ø¬Ø²Ø¦ÛŒØ§Øª Ù…Ø¨Ø§Ø±Ø²Ù‡:**\n"
                f"{challenger_color} **{challenger.first_name}:**\n"
                f"   ğŸ´ {challenger_data['card'].name}\n"
                f"   ğŸ“ˆ {stat_names[challenger_data['stat_type']]}: {challenger_data['stat_value']}\n"
                f"   ğŸ† +{challenger_data['score_gained']} Ø§Ù…ØªÛŒØ§Ø² (Ú©Ù„: {challenger_data['total_score']})\n\n"
                f"ğŸ†š\n\n"
                f"{opponent_color} **{opponent.first_name}:**\n"
                f"   ğŸ´ {opponent_data['card'].name}\n"
                f"   ğŸ“ˆ {stat_names[opponent_data['stat_type']]}: {opponent_data['stat_value']}\n"
                f"   ğŸ† +{opponent_data['score_gained']} Ø§Ù…ØªÛŒØ§Ø² (Ú©Ù„: {opponent_data['total_score']})\n"
            )
            
            # Ø¯ÛŒØ§Ù„ÙˆÚ¯ Ø¨Ø±Ù†Ø¯Ù‡
            dialog = get_victory_dialog(result["winner"]["card"].name)
            if dialog:
                winner_name = result["winner"]["card"].name
                text += f'\n\n{result_emoji} **{winner_name}:** "{dialog}"'
            
            keyboard = [
                [InlineKeyboardButton("ğŸ¥Š Ú†Ø§Ù„Ø´ Ø¬Ø¯ÛŒØ¯", callback_data="request_pvp_fight")],
                [InlineKeyboardButton("ğŸ† Ù„ÛŒØ¯Ø±Ø¨ÙˆØ±Ø¯", callback_data="leaderboard")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await context.bot.send_message(
                chat_id=fight.chat_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode='Markdown'
            )
            # Ø¯Ø± ØµÙˆØ±Øª Ø¨Ø±Ø¯ØŒ ØªØµÙˆÛŒØ± Ú©Ø§Ø±Øª Ø¨Ø±Ù†Ø¯Ù‡ + Ø¯ÛŒØ§Ù„ÙˆÚ¯
            if result_type in ["challenger_wins", "opponent_wins"] and result.get("winner"):
                winner_card = result["winner"]["card"]
                dialog = result.get("dialog") or get_victory_dialog(winner_card.name)
                await send_card_image_safely(
                    message=type("obj", (), {"reply_photo": lambda *args, **kwargs: context.bot.send_photo(chat_id=fight.chat_id, *args, **kwargs)})(),
                    card_name=winner_card.name,
                    config=self.config,
                    caption=dialog
                )
            
            # Ø­Ø°Ù ÙØ§ÛŒØª Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³
            self.db.delete_fight(fight_id)
            
        except Exception as e:
            logger.error(f"Error announcing PvP result: {e}", exc_info=True)

    # ==================== EXISTING CALLBACK HANDLERS ====================

    async def daily_claim_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù…Ø¯ÛŒØ±ÛŒØª Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Øª Ø±ÙˆØ²Ø§Ù†Ù‡"""
        query = update.callback_query
        await query.answer()
        
        # Check panel expiration
        if not ensure_not_expired(query, self.db, context):
            await query.answer("â° Ø§ÛŒÙ† Ù¾Ù†Ù„ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ /start Ø¨Ø²Ù†ÛŒØ¯.", show_alert=True)
            return
        
        user_id = query.from_user.id
        success, card, error = self.game.claim_daily_card(user_id)
        
        if success and card:
            rarity_colors = {
                CardRarity.NORMAL: "ğŸŸ¢",
                CardRarity.EPIC: "ğŸŸ£",
                CardRarity.LEGEND: "ğŸŸ¡"
            }
            color = rarity_colors[card.rarity]
            
            # Ø§Ø±Ø³Ø§Ù„ ØªØµÙˆÛŒØ± Ú©Ø§Ø±Øª Ø¨Ø§ ÛŒÚ© Ø¯ÛŒØ§Ù„ÙˆÚ¯ Ú©ÙˆØªØ§Ù‡
            claim_dialog = get_victory_dialog(card.name)
            image_sent = await send_card_image_safely(query.message, card.name, self.config, f"ğŸ‰ {card.name}\n\nâ€œ{claim_dialog}â€")
            
            # Ù…ØªÙ† Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Øª
            text = (
                f"ğŸ‰ **Ú©Ø§Ø±Øª Ø±ÙˆØ²Ø§Ù†Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯!**\n\n"
                f"{color} **{card.name}** ({card.rarity.value.title()})\n\n"
                f"ğŸ“Š **Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Øª:**\n"
                f"ğŸ’ª Ù‚Ø¯Ø±Øª: {card.power}\n"
                f"âš¡ Ø³Ø±Ø¹Øª: {card.speed}\n"
                f"ğŸ§  Ø¢ÛŒâ€ŒÚ©ÛŒÙˆ: {card.iq}\n"
                f"â¤ï¸ Ù…Ø­Ø¨ÙˆØ¨ÛŒØª: {card.popularity}\n"
                f"ğŸ¯ Ù…Ø¬Ù…ÙˆØ¹: {card.get_total_stats()}\n\n"
                f"âœ¨ **Ø§Ø¨ÛŒÙ„ÛŒØªÛŒâ€ŒÙ‡Ø§:**\n"
            )
            
            for ability in card.abilities:
                text += f"â€¢ {ability}\n"
            
            text += f"\nğŸ• Ú©Ù„ÛŒÙ… Ø¨Ø¹Ø¯ÛŒ: {self.game.CLAIM_COOLDOWN_HOURS} Ø³Ø§Ø¹Øª Ø¯ÛŒÚ¯Ø±"
            
            if not image_sent:
                text = f"ğŸ´ (ØªØµÙˆÛŒØ± Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª)\n\n" + text
            
            keyboard = [
                [InlineKeyboardButton("ğŸ´ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§", callback_data="my_cards")],
                [InlineKeyboardButton("ğŸ”™ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="back_to_main")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.message.reply_text(text, reply_markup=reply_markup, parse_mode='Markdown')
            
        else:
            text = f"âš  **Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Øª**\n\n{error if error else 'Ø®Ø·Ø§ÛŒ Ù†Ø§Ù…Ø´Ø®Øµ!'}"
            
            keyboard = [
                [InlineKeyboardButton("ğŸ´ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§", callback_data="my_cards")],
                [InlineKeyboardButton("ğŸ”™ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="back_to_main")]
            ]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    async def my_cards_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù†Ù…Ø§ÛŒØ´ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±"""
        query = update.callback_query
        await query.answer()
        
        # Check panel expiration
        if not ensure_not_expired(query, self.db, context):
            await query.answer("â° Ø§ÛŒÙ† Ù¾Ù†Ù„ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ /start Ø¨Ø²Ù†ÛŒØ¯.", show_alert=True)
            return
        
        user_id = query.from_user.id
        cards = self.db.get_player_cards(user_id)
        
        if not cards:
            text = (
                "ğŸ”­ **Ù‡Ù†ÙˆØ² Ú©Ø§Ø±ØªÛŒ Ù†Ø¯Ø§Ø±ÛŒØ¯!**\n\n"
                "Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ØŒ Ø§ÙˆÙ„ÛŒÙ† Ú©Ø§Ø±Øª Ø®ÙˆØ¯ Ø±Ø§ Ø±Ø§ÛŒÚ¯Ø§Ù† Ø¯Ø±ÛŒØ§ÙØª Ú©Ù†ÛŒØ¯."
            )
            keyboard = [
                [InlineKeyboardButton("ğŸ Ø¯Ø±ÛŒØ§ÙØª Ú©Ø§Ø±Øª Ø§ÙˆÙ„", callback_data="daily_claim")],
                [InlineKeyboardButton("ğŸ”™ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="back_to_main")]
            ]
        else:
            # Ú¯Ø±ÙˆÙ‡â€ŒØ¨Ù†Ø¯ÛŒ Ø¨Ø± Ø§Ø³Ø§Ø³ Ú©Ù…ÛŒØ§Ø¨ÛŒ
            cards_by_rarity = {"legend": [], "epic": [], "normal": []}
            for card in cards:
                cards_by_rarity[card.rarity.value].append(card)
            
            text = f"ğŸ´ **Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ø´Ù…Ø§ ({len(cards)} Ú©Ø§Ø±Øª):**\n\n"
            
            rarity_info = {
                "legend": ("ğŸŸ¡ **LEGEND**", CardRarity.LEGEND),
                "epic": ("ğŸŸ£ **EPIC**", CardRarity.EPIC),
                "normal": ("ğŸŸ¢ **NORMAL**", CardRarity.NORMAL)
            }
            
            for rarity_key, (rarity_text, rarity_enum) in rarity_info.items():
                cards_list = cards_by_rarity[rarity_key]
                if cards_list:
                    text += f"{rarity_text} ({len(cards_list)}):\n"
                    for card in cards_list:
                        stats = f"ğŸ’ª{card.power} âš¡{card.speed} ğŸ§ {card.iq} â¤ï¸{card.popularity}"
                        text += f"â€¢ {card.name} ({stats})\n"
                    text += "\n"
            
            # Ø³Ø§Ø®Øª Ú©ÛŒØ¨ÙˆØ±Ø¯ Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ø¬Ø²Ø¦ÛŒØ§Øª Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ (ØªØ§ Ø­Ø¯Ø§Ú©Ø«Ø±) + Ø¨Ø§Ø²Ú¯Ø´Øª
            keyboard = []
            max_cards = self.config['game_settings']['max_cards_per_page']
            for card in cards[:max_cards]:
                keyboard.append([InlineKeyboardButton(f"ğŸ” Ø¬Ø²Ø¦ÛŒØ§Øª â€” {card.name}", callback_data=f"card_view_{card.card_id}")])
            keyboard.append([InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_to_main")])
            
            # Ø§Ø¶Ø§ÙÙ‡ Ú©Ø±Ø¯Ù† Ø¯Ú©Ù…Ù‡ PvP Ø§Ú¯Ø± Ø¯Ø± Ú¯Ø±ÙˆÙ‡ Ù‡Ø³ØªÛŒÙ…
            if update.effective_chat.type != 'private':
                keyboard.insert(1, [InlineKeyboardButton("ğŸ¥Š Ú†Ø§Ù„Ø´ PvP", callback_data="request_pvp_fight")])
            
            keyboard.append([InlineKeyboardButton("ğŸ”™ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="back_to_main")])
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    def _get_card_bio(self, name: str) -> str:
        bios = {
            "Heisenberg": "Ø´ÛŒÙ…ÛŒØ¯Ø§Ù† Ù†Ø§Ø¨ØºÙ‡ Ú©Ù‡ Ø¨Ù‡ Ù…Ø³ÛŒØ± ØªØ§Ø±ÛŒÚ© Ù‚Ø¯Ù… Ú¯Ø°Ø§Ø´Øª.",
            "Spongebob": "Ø§Ø³ÙÙ†Ø¬ Ù¾Ø±Ø§Ù†Ø±Ú˜ÛŒ Ø§Ø² Ø²ÛŒØ± Ø¢Ø¨ Ú©Ù‡ Ù‡Ù…ÛŒØ´Ù‡ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª.",
            "Kangfupanda": "Ù¾Ø§Ù†Ø¯Ø§ÛŒ Ø±Ø²Ù…ÛŒâ€ŒÚ©Ø§Ø± Ø¨Ø§ Ù‚Ù„Ø¨ Ø¨Ø²Ø±Ú¯.",
            "Homelander": "Ù‚Ù‡Ø±Ù…Ø§Ù† Ù‚Ø¯Ø±ØªÙ…Ù†Ø¯ Ø¨Ø§ Ú†Ù‡Ø±Ù‡â€ŒØ§ÛŒ Ù¾ÛŒÚ†ÛŒØ¯Ù‡.",
            "Thanos": "ØªØ§ÛŒØªØ§Ù† Ù…Ø¬Ù†ÙˆÙ† Ø¯Ø± Ø¬Ø³ØªØ¬ÙˆÛŒ ØªØ¹Ø§Ø¯Ù„ Ú©Ø§Ø¦Ù†Ø§Øª."
        }
        return bios.get(name, "Ø¨ÛŒÙˆÚ¯Ø±Ø§ÙÛŒ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª.")

    def _get_card_stats_summary(self, user_id: int, card_id: str) -> Dict[str, Any]:
        import sqlite3
        wins = losses = ties = 0
        try:
            conn = sqlite3.connect(self.db.db_path)
            cursor = conn.cursor()
            cursor.execute(
                "SELECT result, COUNT(*) FROM fight_history WHERE user_id=? AND user_card_id=? GROUP BY result",
                (user_id, card_id)
            )
            for res, cnt in cursor.fetchall():
                if res == 'win':
                    wins = cnt
                elif res == 'lose':
                    losses = cnt
                elif res == 'tie':
                    ties = cnt
            conn.close()
        except Exception:
            pass
        total = wins + losses + ties
        wp = round((wins / total) * 100) if total else 0
        lp = round((losses / total) * 100) if total else 0
        tp = round((ties / total) * 100) if total else 0
        return {"wins": wins, "losses": losses, "ties": ties, "total": total, "wp": wp, "lp": lp, "tp": tp}

    async def card_view_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        query = update.callback_query
        await query.answer()
        if not ensure_not_expired(query, self.db, context):
            await query.answer("â° Ø§ÛŒÙ† Ù¾Ù†Ù„ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª.", show_alert=True)
            return
        parts = query.data.split("_")
        card_id = parts[-1]
        card = self.db.get_card_by_id(card_id)
        if not card:
            await query.edit_message_text("âŒ Ú©Ø§Ø±Øª ÛŒØ§ÙØª Ù†Ø´Ø¯!")
            return
        user_id = query.from_user.id
        stats = self.db.get_card_stats(card_id, user_id)
        rarity_map = {
            CardRarity.NORMAL: "ğŸŸ¢ Normal",
            CardRarity.EPIC: "ğŸŸ£ Epic",
            CardRarity.LEGEND: "ğŸŸ¡ Legend"
        }
        header = f"{rarity_map.get(card.rarity, 'ğŸ”¶ Card')} â€” {card.name}"
        text = (
            f"{header}\n"
            f"ğŸ’ª {card.power} âš¡ {card.speed} ğŸ§  {card.iq} â¤ï¸ {card.popularity}\n"
            f"ğŸ“Š Ø¨Ø§Ø²ÛŒâ€ŒÙ‡Ø§: {stats['games_played']}\n"
            f"ğŸ† Ø¨Ø±Ø¯: {stats['wins']} | âŒ Ø¨Ø§Ø®Øª: {stats['losses']} | ğŸ¤ Ù…Ø³Ø§ÙˆÛŒ: {stats['ties']}\n"
            f"ğŸ“ˆ Win Rate: {int(stats['win_rate'])}%\n\n"
            f"ğŸ“ **Biography:**\n{card.biography}"
        )
        # Ø§Ø±Ø³Ø§Ù„ ØªØµÙˆÛŒØ±
        await send_card_image_safely(query.message, card.name, self.config)
        keyboard = [
            [InlineKeyboardButton("ğŸ”™ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="my_cards")]
        ]
        await query.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard), parse_mode='Markdown')

    # AI fight handler removed - AI fights are no longer supported

    # ai_select_card_handler removed - AI fights are no longer supported

    # ai_show_abilities_handler removed - AI fights are no longer supported

    # ai_fight_handler and _show_ai_fight_result removed - AI fights are no longer supported

    async def leaderboard_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ¯Ø±Ø¨ÙˆØ±Ø¯"""
        query = update.callback_query
        await query.answer()
        
        # Check panel expiration
        if not ensure_not_expired(query):
            await query.answer("â° Ø§ÛŒÙ† Ù¾Ù†Ù„ Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ /start Ø¨Ø²Ù†ÛŒØ¯.", show_alert=True)
            return
        
        leaderboard = self.db.get_leaderboard(10)
        
        if not leaderboard:
            text = "ğŸ† **Ù„ÛŒØ¯Ø±Ø¨ÙˆØ±Ø¯ Ø®Ø§Ù„ÛŒ Ø§Ø³Øª!**\n\nÙ‡Ù†ÙˆØ² Ú©Ø³ÛŒ Ø¨Ø§Ø²ÛŒ Ù†Ú©Ø±Ø¯Ù‡!"
        else:
            text = "ğŸ† **Ù„ÛŒØ¯Ø±Ø¨ÙˆØ±Ø¯ Ø¨Ø§Ø²ÛŒÚ©Ù†Ø§Ù† Ø¨Ø±ØªØ±**\n\n"
            
            medals = ["ğŸ¥‡", "ğŸ¥ˆ", "ğŸ¥‰", "4ï¸âƒ£", "5ï¸âƒ£", "6ï¸âƒ£", "7ï¸âƒ£", "8ï¸âƒ£", "9ï¸âƒ£", "ğŸ”Ÿ"]
            
            for i, player_info in enumerate(leaderboard):
                medal = medals[i] if i < len(medals) else f"{i+1}."
                name = player_info.get('first_name', 'Ø¨Ø§Ø²ÛŒÚ©Ù†')
                score = player_info.get('total_score', 0)
                card_count = player_info.get('card_count', 0)
                
                text += f"{medal} **{name}**\n"
                text += f"   ğŸ† {score} Ø§Ù…ØªÛŒØ§Ø² â€¢ ğŸ´ {card_count} Ú©Ø§Ø±Øª\n\n"
        
        keyboard = [
            [InlineKeyboardButton("ğŸ”™ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ", callback_data="back_to_main")]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    async def back_to_main_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ"""
        query = update.callback_query
        await query.answer()
        
        # No expiration check needed for back_to_main as it should always work
        
        user = query.from_user
        user_id = user.id
        
        # Ø¯Ø±ÛŒØ§ÙØª ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ
        player = self.db.get_or_create_player(user_id)
        player = self.game.check_and_reset_hearts(player)
        
        card_count = len(self.db.get_player_cards(user_id))
        
        text = (
            f"ğŸ® **Ù…Ù†ÙˆÛŒ Ø§ØµÙ„ÛŒ**\n\n"
            f"Ø³Ù„Ø§Ù… {user.first_name}! ğŸ‘‹\n\n"
            f"ğŸ“Š **ÙˆØ¶Ø¹ÛŒØª Ø´Ù…Ø§:**\n"
            f"â¤ï¸ Ù‚Ù„Ø¨: {player.hearts}/{self.game.DAILY_HEARTS}\n"
            f"ğŸ´ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§: {card_count}\n"
            f"ğŸ† Ø§Ù…ØªÛŒØ§Ø²: {player.total_score}\n\n"
            f"Ø¹Ù…Ù„ÛŒØ§Øª Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"
        )
        
        keyboard = [
            [InlineKeyboardButton("ğŸ´ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ù…Ù†", callback_data="my_cards")],
            [InlineKeyboardButton("âš”ï¸ Ú†Ø§Ù„Ø´ PvP", callback_data="request_pvp_fight")],
            [InlineKeyboardButton("ğŸ Ú©Ù„ÛŒÙ… Ø±ÙˆØ²Ø§Ù†Ù‡", callback_data="daily_claim")],
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode='Markdown')

    # ==================== SETUP METHODS ====================

    def setup_handlers(self, app: Application):
        """ØªÙ†Ø¸ÛŒÙ… Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ÛŒ Ø±Ø¨Ø§Øª"""
        # Ø¯Ø³ØªÙˆØ±Ø§Øª Ø§ØµÙ„ÛŒ
        app.add_handler(CommandHandler("start", self.start_command))
        app.add_handler(CommandHandler("help", self.help_command))
        app.add_handler(CommandHandler("profile", self.profile_command))
        app.add_handler(CommandHandler("cards", self.cards_command))
        app.add_handler(CommandHandler("claim", self.claim_command))
        app.add_handler(CommandHandler("leaderboard", self.leaderboard_command))
        app.add_handler(CommandHandler("fight", self.fight_command))
        
        # Ú©Ø§Ù„Ø¨Ú©â€ŒÙ‡Ø§ÛŒ Ø§ØµÙ„ÛŒ
        app.add_handler(CallbackQueryHandler(self.daily_claim_handler, pattern="^daily_claim$"))
        app.add_handler(CallbackQueryHandler(self.my_cards_handler, pattern="^my_cards$"))
        
        # AI fight handlers removed - AI fights are no longer supported
        
        # ÙØ§ÛŒØª PvP
        app.add_handler(CallbackQueryHandler(self.request_pvp_fight_handler, pattern="^request_pvp_fight$"))
        app.add_handler(CallbackQueryHandler(self.accept_pvp_fight_handler, pattern="^accept_pvp_"))
        app.add_handler(CallbackQueryHandler(self.accept_pvp_random_handler, pattern="^accept_pvp_random_"))
        app.add_handler(CallbackQueryHandler(self.pvp_card_select_handler, pattern="^pvp_card_"))
        app.add_handler(CallbackQueryHandler(self.pvp_stat_select_handler, pattern="^pvp_stat_"))
        
        # Ø¹Ø¶ÙˆÛŒØª Ú©Ø§Ù†Ø§Ù„
        app.add_handler(CallbackQueryHandler(self.check_membership_handler, pattern="^check_membership$"))
        
        # Ø³Ø§ÛŒØ± Ú©Ø§Ù„Ø¨Ú©â€ŒÙ‡Ø§
        app.add_handler(CallbackQueryHandler(self.leaderboard_handler, pattern="^leaderboard$"))
        app.add_handler(CallbackQueryHandler(self.help_command, pattern="^help$"))
        app.add_handler(CallbackQueryHandler(self.card_view_handler, pattern="^card_view_"))
        app.add_handler(CallbackQueryHandler(self.back_to_main_handler, pattern="^back_to_main$"))
        

    async def error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE):
        """Ù‡Ù†Ø¯Ù„Ø± Ø®Ø·Ø§Ù‡Ø§"""
        logger.error(f"Exception while handling an update: {context.error}", exc_info=context.error)

    async def cleanup_task(self, context: ContextTypes.DEFAULT_TYPE):
        """ØªØ³Ú© ØªÙ…ÛŒØ²Ú©Ø±Ø¯Ù† ÙØ§ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ù…Ù†Ù‚Ø¶ÛŒ"""
        deleted_count = self.db.cleanup_expired_fights()
        if deleted_count > 0:
            logger.info(f"Cleaned up {deleted_count} expired PvP fights")

# ==================== IMAGE SETUP HELPER ====================

def setup_image_directories(config: Dict):
    """Ø§ÛŒØ¬Ø§Ø¯ Ù¾ÙˆØ´Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø² Ø¨Ø±Ø§ÛŒ ØªØµØ§ÙˆÛŒØ±"""
    image_settings = config.get('image_settings', {})
    
    if not image_settings.get('enable_images', False):
        return
    
    # Ø§ÛŒØ¬Ø§Ø¯ Ù¾ÙˆØ´Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²
    cards_path = image_settings.get('card_images_path', '/root/card game/card_images/')
    os.makedirs(cards_path, exist_ok=True)
    os.makedirs(os.path.dirname(cards_path), exist_ok=True)
    
    print(f"ğŸ–¼ Ù¾ÙˆØ´Ù‡â€ŒÙ‡Ø§ÛŒ ØªØµØ§ÙˆÛŒØ± Ø¢Ù…Ø§Ø¯Ù‡ Ø´Ø¯:")
    print(f"   ğŸ´ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§: {cards_path}")

# ==================== MAIN FUNCTION ====================

def main():
    """Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª - ÙˆØ±Ú˜Ù† Ú©Ø§Ù…Ù„ Ùˆ Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡ Ø¨Ø§ PvP + Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø§Ù†Ø§Ù„"""
    # print("ğŸ¤– Ø´Ø±ÙˆØ¹ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø±Ø¨Ø§Øª...")
    
    try:
        # Ø§ÛŒØ¬Ø§Ø¯ Ø±Ø¨Ø§Øª
        bot = TelegramCardBot()
        
        # ØªÙ†Ø¸ÛŒÙ… Ù¾ÙˆØ´Ù‡â€ŒÙ‡Ø§ÛŒ ØªØµØ§ÙˆÛŒØ±
        setup_image_directories(bot.config)
        
        # Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§
        cards = bot.db.get_all_cards()
        if not cards:
            print("ğŸ“¦ Ø§ÛŒØ¬Ø§Ø¯ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ Ù†Ù…ÙˆÙ†Ù‡...")
            added = bot.card_manager.create_sample_cards()
            print(f"âœ… {added} Ú©Ø§Ø±Øª Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯!")
        else:
            print(f"âœ… {len(cards)} Ú©Ø§Ø±Øª Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ù…ÙˆØ¬ÙˆØ¯ Ø§Ø³Øª")
        
        # Ø§ÛŒØ¬Ø§Ø¯ Ø§Ù¾Ù„ÛŒÚ©ÛŒØ´Ù†
        application = Application.builder().token(bot.bot_token).build()
        
        # ØªÙ†Ø¸ÛŒÙ… Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§
        bot.setup_handlers(application)
        application.add_error_handler(bot.error_handler)
        
        # ØªÙ†Ø¸ÛŒÙ… ØªØ³Ú© ØªÙ…ÛŒØ²Ú©Ø±Ø¯Ù† (Ø§Ú¯Ø± JobQueue Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ø¨Ø§Ø´Ø¯)
        if application.job_queue:
            application.job_queue.run_repeating(bot.cleanup_task, interval=3600, first=10)
            print("âœ… ØªØ³Ú© ØªÙ…ÛŒØ²Ú©Ø§Ø±ÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯")
        else:
            print("âš ï¸ JobQueue Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª - ØªÙ…ÛŒØ²Ú©Ø§Ø±ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± ØºÛŒØ±ÙØ¹Ø§Ù„")
        
        # Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ
        print("ğŸ® Ø±Ø¨Ø§Øª Ø¨Ø§Ø²ÛŒ Ú©Ø§Ø±Øª ØªÙ„Ú¯Ø±Ø§Ù… Ø¨Ø§ Ù‚Ø§Ø¨Ù„ÛŒØª PvP Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡")
        print("=" * 50)
        print(f"âœ… Ø±Ø¨Ø§Øª Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³Øª!")
        print(f"ğŸ´ ØªØ¹Ø¯Ø§Ø¯ Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§: {len(bot.db.get_all_cards())}")
        print(f"ğŸ‘¥ ØªØ¹Ø¯Ø§Ø¯ Ø§Ø¯Ù…ÛŒÙ†â€ŒÙ‡Ø§: {len(bot.admin_ids)}")
        print(f"ğŸ–¼ï¸ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø§Ø² ØªØµØ§ÙˆÛŒØ±: {'âœ…' if bot.config.get('image_settings', {}).get('enable_images', False) else 'âŒ'}")
        print(f"ğŸ¥Š Ù‚Ø§Ø¨Ù„ÛŒØª PvP: âœ… ÙØ¹Ø§Ù„ Ùˆ Ø§ØµÙ„Ø§Ø­ Ø´Ø¯Ù‡")
        print(f"â° Ù¾Ù†Ù„â€ŒÙ‡Ø§ Ù…Ù†Ù‚Ø¶ÛŒ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯ Ø¨Ø¹Ø¯ Ø§Ø²: {PANEL_TIMEOUT // 60} Ø¯Ù‚ÛŒÙ‚Ù‡")
        print(f"ğŸ”§ Ù…Ø´Ú©Ù„ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ø§Ø±Øª Ø¯Ø± PvP: âœ… Ø¨Ø±Ø·Ø±Ù Ø´Ø¯Ù‡")
        print(f"ğŸ“¢ Ú©Ø§Ù†Ø§Ù„ Ø§Ù„Ø²Ø§Ù…ÛŒ: {REQUIRED_CHANNEL}")
        print(f"ğŸ”’ Ø¨Ø±Ø±Ø³ÛŒ Ø¹Ø¶ÙˆÛŒØª: âœ… ÙØ¹Ø§Ù„")
        print(f"ğŸ”¥ Ø¨Ø±Ø§ÛŒ Ø´Ø±ÙˆØ¹ Ø¯Ø± ØªÙ„Ú¯Ø±Ø§Ù… /start Ø¨Ø²Ù†ÛŒØ¯!")
        print("=" * 50)
        
        # ØªÙ†Ø¸ÛŒÙ… Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø¨Ø¹Ø¯ Ø§Ø² Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¨Ø±Ø§ÛŒ ØªÙ†Ø¸ÛŒÙ… Ø¯Ø³ØªÙˆØ±Ø§Øª
        async def post_init(app):
            await bot.setup_bot_commands(app)
            print("âœ… Ø¯Ø³ØªÙˆØ±Ø§Øª Ø±Ø¨Ø§Øª Ø¨Ø±Ø§ÛŒ Ù…Ø­Ø¯ÙˆØ¯Ù‡â€ŒÙ‡Ø§ÛŒ Ù…Ø®ØªÙ„Ù ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯")
        
        application.post_init = post_init
        
        # Ø´Ø±ÙˆØ¹ Ø±Ø¨Ø§Øª
        print("ğŸš€ Ø±Ø¨Ø§Øª Ø¯Ø± Ø­Ø§Ù„ Ø§Ø¬Ø±Ø§...")
        application.run_polling(drop_pending_updates=True)
        
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Ø±Ø¨Ø§Øª Ù…ØªÙˆÙ‚Ù Ø´Ø¯!")
    except Exception as e:
        print(f"\nâš  Ø®Ø·Ø§ÛŒ Ú©Ù„ÛŒ: {e}")
        logger.error(f"Critical error: {e}", exc_info=True)

if __name__ == "__main__":
    # Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª
    main()